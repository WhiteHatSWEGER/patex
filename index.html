<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Gas Sensor Dashboard</title>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
		<style>
			body {
				font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
				background-color: #f5f5f7;
				color: #1d1d1f;
				margin: 0;
				padding: 20px;
			}

			.container,
			.container-fluid {
				max-width: 1200px;
				color: #1d1d1f;
				text-align: center;
			}

			.chart,
			.messages,
			.monitor {
				background-color: #ffffff;
				border: 1px solid #e1e1e1;
				border-radius: 10px;
				box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
				margin-bottom: 20px;
				padding: 20px;
			}
		
			.description-container,
				.monitor {
					background-color: #ffffff;
					border: 1px solid #e1e1e1;
					border-radius: 10px;
					box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
					margin-bottom: 20px;
					padding: 20px;
					text-align: center;
				}

			.chart canvas,
			.event-log table,
			.monitor table {
				width: 100%;
			}

			.log-table th,
			.log-table td,
			.monitor-table th,
			.monitor-table td {
				border-color: #e1e1e1;
			}

			.message {
				border: 1px solid #e1e1e1;
				border-radius: 5px;
				margin-bottom: 10px;
				padding: 10px;
			}

			.dark-mode {
				background-color: #1d1d1f;
				color: #f5f5f7;
			}

			.alert-danger {
				background-color: #ff3b30;
				color: white;
			}

			.alert-warning {
				background-color: #ff9500;
				color: white;
			}

			.alert-success {
				background-color: #34c759;
				color: white;
			}

			footer {
				margin-top: 40px;
				text-align: center;
			}
		</style>
	</head>
	<body>
		<nav class="container-fluid">
			<ul>
				<li>
					<strong>
						<a href="#"> Gas Sensor Dashboard</a>
					</strong>
				</li>
			</ul>
			<ul>
				<li>
					<a href="http://127.0.0.1:5000/log">Messages and Log</a>
				</li>
				<li>
					<a href="http://127.0.0.1:5000/toolsData" role="button">Tools and Data</a>
				</li>
			</ul>
		</nav>
		<main class="container">
			<div class="grid">
				<section class="description-container">
				<p>
					This is <br><strong>pATEX</strong><br>your gas monitoring system. <br> No worries about your air, <br>because pATEX will check it for you.
				</p>
			</section>
					<div class="chart">
						<div>
							<input type="checkbox" id="dark-mode-toggle" name="darkMode" />
							<label for="dark-mode-toggle">Dark Mode</label>
						</div>
						<div id="chart-legend"></div>
						<canvas id="hourly-data-chart"></canvas>
						<div class="loading" style="display: none;">Loading...</div>
					</div>
				</section>
			</div>
		</main>
		<footer class="container">
			<small>
				<a href="https://youtu.be/dQw4w9WgXcQ">Privacy Policy â€¢ Terms of Service</a>
			</small>
		</footer>
		<script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.4/dist/Chart.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
		<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.0.2/dist/chartjs-plugin-annotation.min.js"></script>
		<script>
			document.getElementById('dark-mode-toggle').addEventListener('change', function(event) {
				if (event.target.checked) {
					document.body.classList.add('dark-mode');
				} else {
					document.body.classList.remove('dark-mode');
				}
			});

			function customDateFormat(date) {
				const options = {
					hour: '2-digit',
					minute: '2-digit',
					second: '2-digit'
				};
				return new Intl.DateTimeFormat('en-US', options).format(date);
			}

			function getRandomColor() {
				return '#' + Math.floor(Math.random() * 16777215).toString(16);
			}
			const ctx = document.getElementById('hourly-data-chart').getContext('2d');
			const chart = new Chart(ctx, {
				type: 'line',
				data: {
					labels: [],
					datasets: []
				},
				options: {
					tooltips: {
						enabled: true,
						callbacks: {
							label: function(tooltipItem, data) {
								var label = data.datasets[tooltipItem.datasetIndex].label || '';
								if (label) {
									label += ': ';
								}
								label += Math.round(tooltipItem.yLabel * 100) / 100;
								return label;
							}
						}
					},
					scales: {
						yAxes: [{
							ticks: {
								beginAtZero: true,
								max: 120,
								min: 0,
								stepSize: 10
							},
							gridLines: {
								display: true,
								color: 'rgba(0, 0, 0, 0.1)'
							}
						}],
						xAxes: [{
							type: 'time',
							time: {
								unit: 'minute',
								displayFormats: {
									minute: 'HH:mm'
								}
							},
							ticks: {
								display: true,
								maxTicksLimit: 15,
								callback: function(value, index, values) {
									return customDateFormat(new Date(values[index].value));
								}
							},
							gridLines: {
								display: false
							}
						}]
					},
					plugins: {
						datalabels: {
							display: false
						},
						zoom: {
							pan: {
								enabled: true,
								mode: 'x',
							},
							zoom: {
								wheel: {
									enabled: true,
								},
								pinch: {
									enabled: true,
								},
								mode: 'x',
							},
						},
						annotation: {
							annotations: [{
								type: 'line',
								mode: 'horizontal',
								scaleID: 'y-axis-0', // This is typically correct for Chart.js 2.x
								value: 100,
								borderColor: 'lightgrey',
								borderWidth: 2,
								label: {
									enabled: true,
									content: 'Warning Level',
									position: 'start',
								},
							}]
						}
					}
				}
			});
            async function adjustFetchTiming() {
    const timingResponse = await fetch('http://127.0.0.1:5001/api/data-timing');
    const timingData = await timingResponse.json();

    const interval = timingData.interval; // Interval in seconds
    const startTime = new Date(timingData.startTime); // Assuming ISO string format

    // Calculate next expected data generation time
    const now = new Date();
    const elapsed = (now - startTime) / 1000; // Elapsed time in seconds
    const nextInterval = interval - (elapsed % interval);

    setTimeout(fetchSensorData, nextInterval * 1000); // Adjust initial fetch to align with the next data generation interval
}

// Call adjustFetchTiming instead of directly calling fetchSensorData
adjustFetchTiming();

			async function fetchSensorData() {
				try {
					const currentTime = Math.floor(Date.now() / 1000);
					const sixHoursAgo = currentTime - 60 * 60 * 6;
					const response = await fetch(`http://127.0.0.1:5000/api/sensor-data`);
					if (!response.ok) {
						throw new Error(`HTTP error! status: ${response.status}`);
					}
					const data = await response.json();
					data.forEach(sensorData => {
						addDataPoint(new Date(sensorData.timestamp), sensorData.value);
					});
					return data;
				} catch (error) {
					console.error('Error fetching sensor data:', error);
					const errorTime = new Date();
					addDataPoint(errorTime, 0, 0, '#FF0000'); // Add a data point with error color
					return [];
				}
                  finally {
    await adjustFetchTiming(); // Schedule the next fetch
  }
			}
			async function fetchEventLogData(page = 1) {
				try {
					const response = await fetch(`https://your-domain.com/api/event-log?page=${page}`);
					if (!response.ok) {
						throw new Error(`HTTP error! status: ${response.status}`);
					}
					const data = await response.json();
					return data;
				} catch (error) {
					console.error('Error fetching event log data:', error);
					// Add a log entry for the error
					const errorLogEntry = {
						level: 'Error',
						timestamp: new Date().toLocaleString(),
						message: 'Error fetching event log data'
					};
					addLogEntry(errorLogEntry);
					return [];
				}
			}

			function addDataPoint(x, y, datasetIndex = 0, color = getRandomColor()) {
				chart.data.labels.push(x);
				if (!chart.data.datasets[datasetIndex]) {
					chart.data.datasets[datasetIndex] = {
						label: "Sensor Data",
						data: [],
						backgroundColor: color,
						borderColor: color,
						borderWidth: 1,
						fill: false
					};
				}
				chart.data.datasets[datasetIndex].data.push(y);
				chart.update();
			}
			async function updateEventLogTable(page = 1) {
				const eventLogData = await fetchEventLogData(page);
				const eventLogTableBody = document.getElementById('event-log-table');
				eventLogTableBody.innerHTML = '';
				eventLogData.forEach(eventLogEntry => {
					const row = document.createElement('tr');
					row.innerHTML = `
				
										
						<td>${eventLogEntry.level}</td>
						<td>${new Date(eventLogEntry.timestamp).toLocaleString()}</td>
						<td>${eventLogEntry.message}</td>`;
					eventLogTableBody.appendChild(row);
				});
				const paginationList = document.querySelector('.pagination');
				paginationList.innerHTML = '';
				for (let i = 1; i <= Math.ceil(eventLogData.total / eventLogData.per_page); i++) {
					const li = document.createElement('li');
					li.classList.add('page-item');
					if (i === page) {
						li.classList.add('active');
					}
					const a = document.createElement('a');
					a.classList.add('page-link');
					a.href = '#';
					a.textContent = i;
					a.addEventListener('click', (e) => {
						e.preventDefault();
						updateEventLogTable(i);
					});
					li.appendChild(a);
					paginationList.appendChild(li);
				}
			}
			async function fetchLastMessages() {
				try {
					const response = await fetch(`https://your-domain.com/api/last-messages`);
					if (!response.ok) {
						throw new Error(`HTTP error! status: ${response.status}`);
					}
					const data = await response.json();
					return data;
				} catch (error) {
					console.error('Error fetching last messages:', error);
					return [];
				}
			}
			async function updateSensorDataTable() {
				const lastMessages = await fetchLastMessages();
				const sensorDataTableBody = document.getElementById('sensor-data-table');
				sensorDataTableBody.innerHTML = ''; // Clear existing rows
				lastMessages.forEach(message => {
					const row = document.createElement('tr');
					row.innerHTML = `
				
						<td>${message.sensor}</td>
						<td>${message.value}</td>
						<td>${message.unit}</td>
						<td>${new Date(message.time).toLocaleString()}</td>`;
					sensorDataTableBody.appendChild(row);
				});
			}
			async function initializeDashboard() {
				const sensorData = await fetchSensorData();
				if (sensorData.length > 0) {
					sensorData.forEach(data => {
						addDataPoint(new Date(data.timestamp).toISOString(), data.value);
					});
				}
				await updateEventLogTable();
				await updateSensorDataTable(); // Add this line
			}

			function addLogEntry(logEntry) {
				// Implement the logic to add a log entry to your system
				console.log('Adding log entry:', logEntry);
			}
			initializeDashboard();
			document.addEventListener('DOMContentLoaded', function() {
                adjustFetchTiming(); // This now handles the initial and subsequent data fetches
                initializeDashboard()
});

		</script>
	</body>
</html>